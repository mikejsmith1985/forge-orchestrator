Forge Orchestrator: Remediation and Integration Plan (V2.1)Goal: Integrate the feature-rich terminal UX (from V1.6.x User Guide) with the stable, interface-driven backend architecture (V2.1 Contracts). This plan closes the gap where the application was missing its core identityâ€”the Terminal/PTY view.Status: Assumes Contracts 1-5 (Backend Interfaces/Database) are complete.Phase 0: Foundation Check (Go Backend - Already Commited)Objective: Validate that the core architectural pieces are ready to receive the UI and PTY logic.ComponentStatus CheckPurposeData LayerSQLite Ledger initialized and ready.Persistence for Token Ledger is guaranteed.AbstractionsExecutor and LLMGateway interfaces defined.Mandate: Ensures we call all shell commands and LLM APIs through abstracted layers, isolating implementation logic.Wiringapi/execute endpoint and Go server are running.Mandate: Confirms the Frontend can successfully communicate with the Go BFF.Phase 1: Reintegrate Terminal and Execution EngineThis phase closes the most critical contradiction: the lack of a terminal interface. The goal is to make the application a fully functional, WebSocket-driven terminal.Task 1: The Integrated Terminal (PTY Core Implementation)ActionComponent / Files AffectedRationale1.1: Go PTY/WebSocket Serverinternal/server/websocket.goImplement the WebSocket handler to establish and stream the real PTY session (using the Go libraries for PTY/ConPTY management) to the frontend.1.2: React Terminal UI Implementationui/components/Terminal.jsx (New)Integrate xterm.js into the React frontend. This component must connect to the /ws endpoint and display the actual shell output, confirming the app's identity.1.3: Full-Stack PTY TestPlaywright TestValidation Mandate: Test must open the application, simulate typing, and assert that the output from the shell (echo hello) appears in the UI (proving the full WebSocket/PTY loop works).Task 2: Wiring the Executor to the TerminalThis task closes the loop between the Flow logic and the terminal screen.ActionComponent / Files AffectedRationale2.1: Command Injection Logicinternal/execution/local_runner.goImplementation: Update the Execute method to not just run the command, but specifically to write the command string to the active PTY session, simulating a human pressing keys.2.2: PTY Execution Handlerinternal/server/api_handlers.goImplementation: Create a /api/command/execute endpoint that accepts a command string and routes it directly to the active PTY session. This is the API used by Flow Nodes and Command Cards.2.3: Prompt Watcher Logicinternal/execution/auto_respond.goImplementation: Implement the logic that detects confirmation prompts (y/n) in the PTY stream and automatically injects the 'y' response if the Prompt Watcher feature is enabled (per V1.6.x User Guide).Phase 2: UX and Economic RemediationThis phase corrects the conflicts between the old mockups/logic and the new V2.1 economic and structural mandates.Task 3: Flows UI Redesign and CorrectionThis corrects the fundamental contradiction in the Flow Editor.ActionComponent / Files AffectedRationale & Fix3.1: Flow Node Redesignui/views/FlowEditor.jsxFixing the Contradiction: Remove the confusing Agent Role and Provider dropdowns. The node configuration now accepts a simple text input: the full command/prompt string (e.g., copilot -p "refactor...").3.2: Node Type Correctionui/views/FlowEditor.jsxFixing the Disconnect: Ensure the flow component library supports two distinct and separate Node types: LLM Prompt Node (which uses the premium budget) and Shell Command Node (which is zero-token and executes a local script).3.3: Execution Gating UXui/views/FlowEditor.jsxImplementation: Implement the confirmation modal that triggers when a Flow Node is run in 'Premium' mode, forcing the user to confirm consumption of the scarce resource.Task 4: Security and Ledger UI RemediationThis finalizes the necessary UX assurances and fixes the misaligned metrics.ActionComponent / Files AffectedRationale & Fix4.1: Settings Security Fixui/views/Settings.jsxUX Fix: Redesign the key input text to state: "Your key will be Encrypted and stored in the OS Keyring," providing the necessary security assurance missing from the original UI.4.2: Dynamic Budget Meterui/components/Architect.jsxEconomic Mandate: Implement the dynamic logic to display the remaining budget using the correct currency (TOKEN or PROMPT) based on the active model's configuration.4.3: Ledger Metrics Fixui/views/Dashboard.jsxData Integrity Fix: Update the Ledger table component to show cost and usage based on the Primary Cost Unit (PROMPT or TOKEN), avoiding the misleading mixing of currencies in reporting.This plan ensures that the resulting application is a single, cohesive system where the terminal is the central hub, and all flows correctly integrate with the local shell while adhering to the token economy rules.