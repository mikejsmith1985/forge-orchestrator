Project Charter: Forge Orchestrator (A.K.A. The Agent Orchestration Platform)Vision: To build the command-line interface (CLI) for the future of development, where the developer‚Äôs primary role is orchestrator and token manager, maximizing the efficiency and output of AI coding agents. This tool eliminates context switching by providing a visual, audit-ready layer on top of all terminal operations.Project Status: Rebuilding from scratch in a new, dedicated repository (Forge-Orchestrator).1. Core Architectural & Strategic CommitmentsAreaDecision / StrategyRationaleCodebaseREBUILD FROM SCRATCH in a new repo.The existing architecture is inadequate for token management and the high-agility UX required.ArchitectureGo BFF + React/TypeScript UI (Single Binary Deployment).Provides the necessary stability (Go) and front-end agility (React) for complex UX/Vision features.Agent SourcingCRITICAL: All agents are SIMULATED ROLES created by wrapping a single LLM API/CLI (e.g., Claude Code, Gemini CLI) with highly specific System Prompts. The Go BFF is the LLM Gateway that manages all routing logic.Preserves architectural simplicity while achieving behavioral specialization and setting the foundation for true multi-model routing.2. Methodology & Agentic WorkflowA. The Agentic Orchestration Model (4 Agents - Simulated Roles)Agent RoleResponsibilityHandoff Method (Input/Output)1. Orchestrator Agent (Planner)Project Planning & Decomposition. Decomposes high-level goals into token-optimized GitHub Issues (contracts).Output: Generates rigid, token-optimized GitHub Issue Contracts and uses the Project Charter/README for long-term context.2. Implementation Agent (Dev)Coding & Feature Implementation. Writes all Go, React, and TypeScript logic.Input: Consumes the GitHub Issue contract. Output: Commits feature code, Playwright Test file, and sends a WebSocket Signal upon completion.3. Test Agent (QA/Execution)User Experience Validation. Executes the committed Playwright tests against the local running server.Validation: Confirms the UX renders correctly and the user can interact with it. (Focuses on UI rendering, not API 200 codes.)4. Token Optimizer Agent (Auditor)Efficiency & Cost Reduction. Analyzes historical data from the Token Ledger.Output: Generates new optimization suggestions (e.g., shorter prompts, simpler flows) for the Orchestrator Agent.B. Feature EvolutionFeatureV1.1 (Original) RoleV2.0 (New) RoleCommand CardsRun a single, simple CLI command (git status).The Utility Shot / Token-Optimized Speed Dial. Stores the most token-efficient prompt for a single, common LLM task. Bypasses the Flow editor.Flows EditorBuild multi-step automation.Build multi-step, time-aware, multi-agent Orchestration Pipelines.3. Implementation and User Experience Gaps (Finalized)A. Core UX FeaturesFeatureDescriptionRationaleForge ArchitectToken Preview Meter: As the user types their "brain dump," the UI displays the estimated token count in a color-coded budget meter (Green $\rightarrow$ Red).Makes token management an immediate, educational, and intuitive part of the UX.Token LedgerAudit Flow Playback: Displays the Token Optimizer Agent's suggestions with a "Click to Apply" button that instantly updates the associated Flow Node/Command Card.Closes the learning loop by making optimization actionable with zero friction.B. Security & ReliabilitySecurity GoalImplementation in Go BFFMitigation of RiskToken Ledger IntegrityGo BFF must implement advanced output stream parsing (regex/marker detection) to reliably extract clean JSON/token counts from noisy CLI output streams.Solves the risk of brittle logic failing due to non-standard CLI output and ensures the ledger data is accurate.WebSocket SignalingGo Flow Engine uses WebSockets for primary signaling, but implements a GitHub Commit Check as a fallback if the signal fails.Ensures the system is resilient; Flow will not get stuck waiting if the local network fails or an agent crashes mid-signal.Secure API Key StorageKeys are encrypted using OS-native key managers (Keychain, Credential Manager) via Go and are never exposed to the browser.Prevents API key theft.Transport & Access ControlHTTPS/WSS used locally. Go enforces strict CORS restrictions.Prevents external scripts or malicious websites (CSRF/XSS) from running unauthorized commands.4. Operational & Distribution StrategyA. Branching Strategy: GitHub Flow (Trunk-Based)Strategy: GitHub Flow. All work branches from, and merges back into, main.Rationale: Aligns with rapid velocity, small token-optimized commits, and continuous integration.B. Pull Request (PR) Template Requirements## Pull Request: [Agent-Generated Feature/Fix]

**1. üé´ Related Issue (Created by Orchestrator Agent):** [Link to GitHub Issue #XXX]

**2. üìä Token Efficiency Report (Generated by Implementation Agent):**
- **Estimated Input Tokens:** [Agent fills this out based on files read/prompt size]
- **Actual Output Tokens:** [Agent fills this out upon completion]
- **Optimization Strategy:** [e.g., Used `--output json` flag, only read `src/main.go`, not the whole folder.]

**3. üèûÔ∏è Visual Validation (UX-First):**
- [ ] Screenshot / GIF of the rendered **Forge Vision** component working. (Proof that the UI works)
- [ ] Confirmed responsiveness on a mobile viewport (360px width check).

**4. üß™ Testing Contract Status (Generated by Implementation Agent):**
- [ ] The **Playwright Test** file has been created/updated: `tests/e2e/test_[feature].spec.ts`
- [ ] The local Playwright tests **PASSED** before submitting this PR.

**5. ‚úÖ Code Review Checklist:**
- [ ] New/modified code adheres to **Self-Documenting Code** principle (plain-English comments).
- [ ] No `curl` or `grep` used in tests‚Äîall validation is UX-focused (Playwright).
